{"tagline":"A web development framework written in Kotlin","google":"","note":"Don't delete this file! It's used internally to help with page regeneration.","name":"Kara","body":"# Kara Web Framework\r\n\r\nKara is a web framework for the JVM using the [Kotlin programming language](http://confluence.jetbrains.net/display/Kotlin/Welcome).  It uses Kotlin's unique syntax to allow developers to write succinct, statically-typed HTML and CSS all in one language.\r\n\r\n## Overview\r\n\r\nKara is still atan alpha stage, but it contains the following feature set:\r\n\r\n* A Rails-like MVC architecture, where controllers contain business logic and views render the output.\r\n* A statically-typed HTML view engine written in Kotlin\r\n* Support for generating JSON responses directly from objects\r\n* A statically-typed CSS rendering engine to compose stylesheets\r\n* A Jetty-based embedded web server that automatically reloads the application when it's rebuilt\r\n* A flexible JSON-based configuration system\r\n* A project and file generator system to aid in setting up your code\r\n* An environment system for different runtime environments\r\n\r\nAs a project in heavy development, there are still a number of **planned** features that **have yet to be implemented**:\r\n\r\n* Much more documentation, clearly\r\n* Integration with Kotlin's Javascript compiler to generate Javascript from Kotlin code (regular Javascript is currently supported)\r\n* A deployment generator that creates servlet-ready WAR files\r\n* Asset compilation and minification\r\n* A plugin architecture that allows plugins for integrating third-party libraries\r\n\r\nThere are several features that are **not planned** for Kara, since we feel they fall outside of the scope of the framework:\r\n\r\n* Support for different HTML template engines (JSP, FreeMaker, Velocity, Jade, etc.)\r\n* Support for different Javascript wrappers (Coffeescript, TypeScript, Dart, etc.)\r\n* A database integration library. There are plenty of good ORM's for the JVM, and while there's a chance that Kotlin could be used to do some interesting things with mapping databases, this can be developed independently of Kara\r\n\r\n### Philosophy\r\n\r\nKara is not intended to be everything to ever one. There are slews of excellent web frameworks out there that meet a wide range of needs for developers.\r\nIf you're looking for something that lets you use a dynamic language with really simple syntax, or use proper HTML markup that a designer can edit, you'd be better served by something like Rails or Django.\r\n\r\nKara's specific goal is to make a web framework that focuses on developer productivity while maintaining a safe yet powerful syntax for defining markup.\r\nThe HTML view DSL is more concise than most markup languages used today, yet maintains strong type safety to help avoid common pitfalls that you'd experince in dynamic languages.\r\nPlus, Kotlin is an excellent language to develop with - letting you easily express complex ideas through simple code that leverages the power of the JVM.\r\n\r\n\r\n## Installation\r\n\r\nTo install Kara, simply checkout the repository and add the location to your system path.\r\n\r\n### Platforms and Prerequisites\r\n\r\nTo run Kara, the only concrete prerequisite is a working JDK. Optionally, [Ant](http://ant.apache.org/) can be used to enable automatic server restart during development.\r\n\r\nTo develop a Kara app, it is highly recommended to use [IntelliJ IDEA](http://www.jetbrains.com/idea/) with the [Kotlin Plugin](http://confluence.jetbrains.net/display/Kotlin/Getting+Started).\r\n\r\nSo far, Kara has only been tested on Mac OS X. However, the runtime is obviously platform independent and the bash script should work fine on any other *nix. In order to get it to work on Windows, we'll need to develop a batch file to run it.\r\n\r\n\r\n## Command Line Usage\r\n\r\nHere's an overview of the Kara command line usage:\r\n\r\n\r\n    Usage:\r\n        kara [-options] command args\r\n\r\n    Commands:\r\n        c, config    Show the application's configuration for the current environment\r\n        g, generate  Generates a new project or file (see below)\r\n        h, help      Show this help message\r\n        s, server    Run the Kara server on the current directory\r\n\r\n    Options:\r\n        -d, --debug  Show debug log messages\r\n        -e, --env    Specify the environment (default is --env=development)\r\n        -i, --info   Show info log messages (default)\r\n        -w, --warn   Show only warning log messages\r\n\r\n    Generators:\r\n        project <name>      Generates a new Kara project with the given name.\r\n\r\n                            Use the --package=<package> option to specify a package\r\n                            that's different than the project name.\r\n\r\n\r\n                            Use the --ide=ide_name option to specify a package\r\n                            that can be opened directly in the IDE of choice.\r\n\r\n                            Currently supports: 'idea' for IntelliJ IDEA\r\n\r\n        update              Updates the application's Kara dependency to the latest version\r\n        \r\n        controller <name>   Generates a new controller with the given name.\r\n                            \"Controller\" will be automatically appended to the name)\r\n    \r\n        view <controller> <view>  Generate a new view for the given controller.\r\n\r\n### Creating a Project\r\n\r\nTo create a Kara project, navigate to the directory you'd like the new project in and run something like:\r\n\r\n    kara generate project MyKaraApp --package=com.example\r\n\r\nThis will create a new project in MyKaraApp with the package com.example. At this point, the project is just a set of directories and some boilerplate code.\r\n\r\nTo import the project into the IDE, it is recommended to specify the --ide option with your IDE of choice. To import into IntelliJ IDEA, use --ide=idea and then you can just open up the project and build it in IDEA without further steps.\r\n\r\n\r\n**Recommended:** you can add the build.xml file that Kara generates to IDEA's Ant tasks and set it to be executed after compilation.\r\nThis will force the Kara server to reload the application code whenever it's rebuilt.\r\n\r\n\r\n### Running the Development Server\r\n\r\nOnce the project is built, it can be run in the development server by simply running:\r\n\r\n    kara server\r\n\r\nThe server will reload the application code whenever the tmp/restart.txt file is touched:\r\n\r\n    touch tmp/restart.txt\r\n\r\n\r\n### Other Generators\r\n\r\nTo create a new controller in your existing project, simply run something like:\r\n\r\n    kara generate controller Blog\r\n\r\nwhich will create a controller called BlogController.\r\n\r\nTo create a new view in your existing project, run something like:\r\n\r\n    kara generate view Blog List\r\n\r\nwhich will generate a view called List that belongs to the BlogController.\r\n\r\nSince the Kara library is shipped with the Kara installation and changes frequently, it's often necessary to update the KaraLib.jar file in your application's lib folder.\r\nRunning the *update* generator will do just that:\r\n\r\n    kara generate update\r\n\r\n\r\n## Project Structure\r\n\r\nHere's the general structure of a Kara project:\r\n\r\n    /bin                            Binary output (.class files)\r\n    /config                         Application config files\r\n    /lib                            Third party libraries\r\n    /public/images                  Image resources\r\n    /public/javascripts             Javascript source files\r\n    /public/stylesheets             CSS stylesheets (third party or generated)\r\n    /public/system                  App-generated files that need to persist between deployments\r\n    /src/<package>/controllers      Application controllers\r\n    /src/<package>/models           Database integration\r\n    /src/<package>/styles           Stylesheet sources\r\n    /src/<package>/views            HTML view sources\r\n    /tmp                            Temporary files, like sessions\r\n\r\n\r\n## Views\r\n\r\nHTML views in Kara are created using a custom Kotlin DSL. Each view inherits from kara.view.HtmlView and looks like this:\r\n\r\n    class Index() : HtmlView() {\r\n        override fun render(context: ActionContext) {\r\n            h2(\"Welcome to Kara\")\r\n            p(\"Your app is up and running, now it's time to make something!\")\r\n            p(\"Start by editing this file here: src/com/karaexample/views/home/Index.kt\")\r\n        }\r\n    }\r\n\r\nAs you can see, the actual view markup is placed in the overriden render() method.\r\nThe render() method accepts one argument, the action context.\r\nThis context hold references to the action's request, response, session, and parameters.\r\n\r\nSome more complex view markup might look like this:\r\n\r\n    ol {\r\n        li(\"List Item 1\")\r\n        li(\"List Item 2\")\r\n    }\r\n    fieldset() {\r\n        label(\"Text Input\")\r\n        input(inputType=\"text\", value=\"Text\")\r\n    }\r\n    p {\r\n        + \"Some text\"\r\n        + \"Some more text\"\r\n    }\r\n\r\nEach function represents a single HTML tag, and accepts arguments for the tag's attributes.\r\nThe last argument is an optional function literal that can be used to populate the tag's children (as with the ol and fieldset tags above).\r\nText content can either be passed directly to the tag function, or added inside its body with the + operator.\r\n\r\nThis flexible markup mechanism highlights the power of the Kotlin syntax, and can't be acheived in languages like Java or even Scala.\r\n\r\n### Layouts\r\n\r\nApplications generally contain HTML markup that's shared between views.\r\nIn Kara (as well as many other web frameworks) these are called layouts.\r\nBy convention, layout files are placed in the root of the app's views directory.\r\nEach layout inherits from the *HtmlLayout* class. Consider the following example:\r\n\r\n    class DefaultLayout() : HtmlLayout() {\r\n        override fun render(context: ActionContext, mainView: HtmlView) {\r\n            head {\r\n                title(\"Kara Demo Title\")\r\n                stylesheet(DefaultStyles())\r\n            }\r\n            body {\r\n                h1(\"Kara Demo Site\")\r\n                div(id=\"main\") {\r\n                    renderView(context, mainView)\r\n                }\r\n                a(text=\"Kara is developed by Tiny Mission\", href=\"http://tinymission.com\")\r\n            }\r\n        }\r\n    }\r\n\r\nAs with views, a layout's markup is placed in the render() method, which accepts the current action context, as well as the main view to render.\r\nThe mainView is rendered with the renderView() function.\r\n\r\nAt this point, the layout used to render each view is specified at the controller level (either passed to the constructor, or specified later inside an action).\r\n\r\n\r\n### Forms\r\n\r\nKara has a special form builder tag that allows you to generate form markup directly from a model object using reflection. For example:\r\n\r\n    class BookForm(val book : Book) : HtmlView() {\r\n        override fun render(context: ActionContext) {\r\n            h2(\"Book Form\")\r\n            formFor(book, \"/updatebook\", FormMethod.Post) {\r\n                p {\r\n                    labelFor(\"title\")\r\n                    textFieldFor(\"title\")\r\n                }\r\n                p {\r\n                    labelFor(\"isPublished\", \"Is Published?\")\r\n                    checkBoxFor(\"isPublished\")\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\nIn this case, the view itself accepts an argument for a model object - book - which is used during the rendering process.\r\nThe formFor method generates the form tag and binds all contained form methods to that form.\r\nIn this case, we generate labels, a text field, and a check box.\r\nThe values for those fields will be automatically populated with the corresponding properties from the model object.\r\n\r\n\r\n## Stylesheets\r\n\r\nLike HTML views, CSS stylesheets are also defined with a Kotlin DSL. A stylesheet inherits from kara.styles.Stylesheet, and looks like this:\r\n\r\n    class DefaultStyles() : Stylesheet() {\r\n        override fun render() {\r\n            s(\"body\") {\r\n                backgroundColor = c(\"#f0f0f0\")\r\n            }\r\n            s(\"#main\") {\r\n                width = 85.percent\r\n                backgroundColor = c(\"#fff\")\r\n                margin = box(0.px, auto)\r\n                padding = box(1.em)\r\n                border = \"1px solid #ccc\"\r\n                borderRadius = 5.px\r\n            }\r\n\r\n            s(\"input[type=text], textarea\") {\r\n                padding = box(4.px)\r\n                width = 300.px\r\n            }\r\n            s(\"textarea\") {\r\n                height = 80.px\r\n            }\r\n\r\n            s(\"table.fields\") {\r\n                s(\"td\") {\r\n                    padding = box(6.px, 3.px)\r\n                }\r\n                s(\"td.label\") {\r\n                    textAlign = TextAlign.right\r\n                }\r\n                s(\"td.label.top\") {\r\n                    verticalAlign = VerticalAlign.top\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\nEach selector is declared with the s() function, and it's attributes are set inside a function literal.\r\nAll possible CSS attributes are mapped to properties on the selector, and strongly-typed enums are used for attributes with a predefined set of possible values.\r\nSelector nesting is automatically handled by nesting s() calls and generates the appropriate compound selectors.\r\n\r\nNote that special value types exist for dimensional and color attributes. These include:\r\n\r\n* Linear dimensions (like width, height, borderRadius, etc.) - created using extension functions on numeric values (i.e. 1.5.em, 3.px, 25.percent)\r\n* Box dimensions (like padding and margin) - created using the box() function, which accepts 1-4 linear dimenions using the same logic as their CSS counterparts\r\n* Colors - created using the c() function and passing a string defining the color\r\n\r\nBecause the CSS markup is defined using Kotlin itself, the DSL renders CSS preprocessing libraries like SASS and LESS obselete.\r\nVariable and macros can be defined right in code, either inside the style class or as separate functions to share amongst several styles.\r\n\r\n\r\n## Controllers\r\n\r\nThe business logic for a Kara app is contained inside the controllers.\r\nEach controller is a class that inherits from kara.controllers.BaseController, and defines one or more action methods.\r\nAn action method handles a specific request to the app, defined by the routing parameters associated with it, and returns an ActionResult.\r\n\r\n    class HomeController() : BaseController(DefaultLayout()) {\r\n        Get(\"/\") fun index() : ActionResult {\r\n            return Index()\r\n        }\r\n\r\n        Get(\"/test\") fun test() : ActionResult {\r\n            return TextResult(\"This is a simple text action\")\r\n        }\r\n\r\n        Post(\"/updatebook\") fun update() : ActionResult {\r\n            return RedirectResult(\"/forms\")\r\n        }\r\n    }\r\n\r\nThe controller above has three actions (index, test, and update). The first two respond to GET requests at / and /test, respectively.\r\nThe update action responds to POST requests at /updatebook.\r\n\r\nIf the route doesn't start with /, it's relative to the current controller.\r\nThe lowercase name of the controller, minus *controller*, is used as the first component of the route.\r\nAny pound signs are replaced with the name of the action method.\r\n\r\n    class FooController() : BaseController(DefaultLayout()) {\r\n        Get(\"\") fun index() : ActionResult {\r\n            // maps to /foo\r\n        }\r\n\r\n        Get(\"bar\") fun bar() : ActionResult {\r\n            // maps to /foo/bar\r\n        }\r\n\r\n        Get(\"#\") fun blank() : ActionResult {\r\n            // maps to /foo/blank\r\n        }\r\n\r\n        Get(\":id/#\") fun edit(id : Int) : ActionResult {\r\n            // maps to /foo/3/edit\r\n        }\r\n    }\r\n\r\nThe routing mechanism allows for more complex routes, like:\r\n\r\n    Get(\"complex/*/list/:id\") fun complex() : ActionResult {\r\n        return TextResult(\"complex: ${params[0]} id = ${params[\"id\"]}\")\r\n    }\r\n\r\nIn this case, the asterisk acts as a wildcard (matching any value at that location), and :id acts as a named route parameter.\r\nThe parameter values are available inside the request through the controllers RouteParams object:\r\n\r\n    this.params[0] // wildcard param\r\n    this.params[\"id\"] // named :id param\r\n\r\nWhen compound objects are passed as form parameters, they can be retrieved as a hash:\r\n\r\n    // if form contains: book[title]=Foundation&book[author]=Isaac%20Asimov\r\n    this.params.getHash(\"book\") // will return a has with {title=\"Foundation\", author=\"Isaac Asimov\"}\r\n\r\nThe most common ActionResult is an HtmlView, but you can also return raw text with TextResult(), JSON objects with JsonResult(), and redirects with RedirectRestul().\r\n\r\n\r\n## Configuration\r\n\r\nEach Kara application is configured with a set of JSON configuration files.\r\nKara encourages convention-over-configuration, so these files are generated for you when you create the project and don't need to be edited at all to get going.\r\n\r\nThe primary config file is located at config/appconfig.json. By default, it looks like this:\r\n\r\n    {\r\n         \"kara\": {\r\n             \"appPackage\": \"<package>\",\r\n             \"publicDir\": \"public\",\r\n             \"stylesheetDir\": \"stylesheets\",\r\n             \"sessionDir\": \"tmp/sessions\"\r\n         }\r\n    }\r\n\r\nEven though the file itself contains nested objects, Kara flattens all of the keys by joining them with periods.\r\nSo, the file above is interpreted as:\r\n\r\n    kara.appRoot: <path to project>\r\n    kara.port: 3000\r\n    kara.publicDir: public\r\n    kara.appPackage: <package>\r\n    kara.sessionDir: tmp/sessions\r\n    kara.stylesheetDir: stylesheets\r\n\r\nYou can view the flattened configuration at any time by running\r\n\r\n    kara config\r\n\r\nThe default config file contains just the values that Kara uses directly.\r\nHowever, you can specify your own custom values:\r\n\r\n    {\r\n        \"kara\": {\r\n            \"appPackage\": \"<package>\",\r\n            \"publicDir\": \"public\",\r\n            \"stylesheetDir\": \"stylesheets\",\r\n            \"sessionDir\": \"tmp/sessions\"\r\n        }\r\n        \"mylib\": {\r\n            \"value1\": \"foo\"\r\n            \"value2\": \"bar\"\r\n        }\r\n    }\r\n\r\nThis can be useful for configuring third party libraries without needing to define your own file format and reading mechanism.\r\nThe config values can be retrieved from an appConfig instance (available in the controllers and ActionContexts):\r\n\r\n    val value1 = appConfig[\"mylib.value1\"]\r\n\r\n### Environments\r\n\r\nBesides the default appconfig.json file, you can have config files for each runtime environment that are named like appconfig.<environment>.json.\r\nValues in the environment config file will override those in the default file.\r\nBy default, Kara creates an appconfig.development.json file, but you can create others for as many environments as you want.\r\n\r\n\r\n## Authors\r\n\r\nKara is developed by [Tiny Mission](http://tinymission.com). We're a small web and mobile development company and hope to use Kara to help us work faster and write better code.\r\n\r\n\r\n## Contributing\r\n\r\nThere's plenty of work left to do to make Kara a first class framework, and we'd welcome contributions. Contact andy at tinymission.com to get involved.\r\n\r\n\r\n## License\r\n\r\nKara is Open Source and licensed under the Apache Licenses, version 2.0. It can be freely used in commercial projects.\r\n"}